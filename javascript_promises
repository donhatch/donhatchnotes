Trying to learn javascript promises.
Very good material:
  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
  https://davidwalsh.name/promises
  http://www.html5rocks.com/en/tutorials/es6/promises/
  http://www.sitepoint.com/overview-javascript-promises/
  http://www.datchley.name/es6-promises/
  https://www.promisejs.org/
  http://www.mattgreer.org/articles/promises-in-wicked-detail/

  http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html (especially see "Advanced mistakes" which is actually a nice collection of good practices)
  http://stackoverflow.com/questions/33377614/nolans-promises-a-javascript-puzzles

  https://developers.google.com/web/updates/2015/03/introduction-to-fetch
  https://davidwalsh.name/fetch

  http://blog.soareschen.com/the-problem-with-es6-promises -- good, articulates my concern about return values
  https://github.com/soareschen/es6-promise-debugging -- supposedly addresses it?  I didn't see it addressed

  https://www.stephanboyer.com/post/107/fun-with-promises-in-javascript -- good critique of the "helpful" behavior and how it should have been done (Surprise #1)




I'm having a really hard time absorbing it.


==================
http://stackoverflow.com/questions/36178889/after-adding-a-listener-to-a-promise-should-i-use-the-original-promise-or-the-n
Q: after adding a listener to a Promise, should I use the original promise or the new one?

I have some javasript code that takes an existing promise
(say, the promise returned by fetch()) and adds value
(say, then/catch listeners for debugging, or maybe more):

<code>let myFetch = function(url) {
  return fetch(url).then(function(value) {
    console.log("fetch succeeded: value=",value);
    return value;
  }.catch(function(reason) {
    console.log("fetch failed: reason=",reason);
    throw reason;
  });
};
</code>

I found myself modifying the above code so that the listeners are only added if some condition is true:

<code>let myFetch = function(url) {
  let promise = fetch(url);
  if (some condition) {
    promise = promise.then(function(value) {
      console.log("fetch succeeded: value=",value);
      return value;
    }.catch(function(reason) {
      console.log("fetch failed: reason=",reason);
      throw reason;
    });
  }
  return promise;
};
</code>

Now I'm wondering, does it really make sense for myFetch to return the new promise returned by "then"
(actually catch which is shorthand for another "then") as above,
or would it make more sense for it to return the original promise (with the added listeners)?
In other words, I'm thinking of leaving out the second "promise =",
so that the code will look like this instead:

<code>let myFetch = function(url) {
  let promise = fetch(url);
  if (some condition) {
    promise.then(function(value) {
      console.log("fetch succeeded: value=",value);
      return value;
    }.catch(function(reason) {
      console.log("fetch failed: reason=",reason);
      throw reason;
    });
  }
  return promise;
};
</code>

Is that effectively different from the previous version?
Is either version preferable, and if so, why?

==================
==================
I posted this:
http://stackoverflow.com/questions/35375730/is-javascript-promise-api-more-convoluted-than-it-needs-to-be
Q: Is javascript Promise API more convoluted than it needs to be?

I think I have finally managed to bend my mind around javascript/ES6 Promises, for the most part.  It wasn't easy!  But there's something that's baffling me about the design.

Why does the Promise constructor take a callback?  Given that the callback is called immediately, couldn't the caller just execute that code instead, thereby avoiding one unnecessary level of mind-bending "don't call me, I'll call you"?

Here's what I think of as the prototypical example of Promise usage, copied from Jake Archibald's Javascript Promises tutorial http://www.html5rocks.com/en/tutorials/es6/promises/#toc-promisifying-xmlhttprequest , with comments stripped.  It's a Promise-based wrapper for an XMLHttpRequest GET request:

<code>function get(url) {
  return new Promise(function(resolve, reject) {
    var req = new XMLHttpRequest();
    req.open('GET', url);
    req.onload = function() {
      if (req.status == 200) {
	resolve(req.response);
      }
      else {
	reject(Error(req.statusText));
      }
    };
    req.onerror = function() {
      reject(Error("Network Error"));
    };
    req.send();
  });
}
</code>

For me, the above code would be much easier to understand if it were rewritten as follows, using a very slightly different kind of promise that I'm imagining, having a no-arg constructor and resolve/reject methods:

<code>function get(url) {
  var promise = new MyEasierToUnderstandPromise();

  var req = new XMLHttpRequest();
  req.open('GET', url);
  req.onload = function() {
    if (req.status == 200) {
      promise.resolve(req.response);
    }
    else {
      promise.reject(Error(req.statusText));
    }
  };
  req.onerror = function() {
    promise.reject(Error("Network Error"));
  };
  req.send();

  return promise;
}
</code>

MyEasierToUnderstandPromise is not too hard to implement in terms of Promise.  At first I tried making it an actual subclass of Promise, but for some reason I couldn't get that to work; so instead I implemented it as a simple factory function, which returns a plain old Promise object with a couple of extra functions
attached that behave like member functions:

<code>function NewMyEasierToUnderstandPromise() {
  var resolveVar;
  var rejectVar;
  var promise = new Promise(function(resolveParam, rejectParam) {
    resolveVar = resolveParam;
    rejectVar = rejectParam;
  });
  promise.resolve = resolveVar;
  promise.reject = rejectVar;
  return promise;
};
</code>

So, why isn't Promise designed like this?  I think if it was, it would have helped me to understand Promises a lot quicker-- I bet it would have cut my learning time in half.

I know a lot of smart people had a hand in making the Promise API, and everyone seems to be generally happy and proud of it, so I'm wondering what they were thinking.




===========================
<code>
  function MyEasierToUnderstandPromise() {
    Promise.call(this, function(resolve, reject) {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
</code>


===============================================================================
Q: Why doesn't javascript Promise support multiple value args?
   It makes it awkward to convert old non-promise-based API, e.g.
   the new version typically looks like this:
     promise.then(function(valueArray) {
         let value0 = valueArray[0];
         let value1 = valueArray[1];
         let value2 = valueArray[2];
         ...
     });
   whereas the callback is more naturally written as:
     function(value0, value1, value2) { ... }
A: Well, "resolve" and "then" have to return a value, but return values can't
   be multiple.  Arguably it would have worked if "resolve" and "then"
   *always* return an array, but I guess the library designers wanted to
   optimize for the common case of a single return value instead.
   However, there is something called "spread" in some promise libraries:
     http://bluebirdjs.com/docs/api/spread.html
   That lets the above be written as:
      promise.spread(function(value0, value1, value2) { ... })
   However, this is really unnecessary in most cases, as pointed out in the
   Bluebird doc; it can be rewritten using ES6 destructuring syntax as:
      promise.spread([value0, value1, value2]) { ... })
===============================================================================
http://stackoverflow.com/questions/36312648/how-does-promise-resolution-decide-whether-to-treat-a-return-value-as-a-promise
Q: how does promise resolution decide whether to treat a return value as a promise or as a plain value?

Promise resolution "helpfully" does different things depending on whether the return value of resolve() or the return value of the function passed to then() is a promise or not.

Therefore, understanding and predicting the behavior requires knowing precisely what criterion is being used (or is allowed to be used) to determine whether something "is a promise" as I use the phrase in the above sentence, so I'd like to nail that down.  I'm interested in Promises/A+ in general, and ES6 native promises in particular.

Looking to https://promisesaplus.com/, it says:

    1.1 "promise" is an object or function with a "then" method whose behavior conforms to this specification.

To see what that means, I look further into 2.2 "The then method", and find that it rests on a set of
behavior criteria making it clearly impossible to decide algorithmically whether a given object
is a promise or not (proof by Halting Problem).  And that's fine; it just means the spec
of the "helpful" behavior in question won't be using the term "is a promise" directly.

So, looking further for the spec of the "helpful" behavior, I find 2.3 "The Promise Resolution Procedure".
Surprise!  It *does* use the term "is a promise" directly:

    2.3.2 If x is a promise, adopt its state [3.4]

But it saves itself from a descent into meaninglessness in the footnote:

    [3.4] Generally, it will only be known that x is a true promise if it comes from the current implementation. This clause allows the use of implementation-specific means to adopt the state of known-conformant promises.

In other words, 2.3.2 didn't really mean "If x is a promise", it really meant (and should have said, IMO) "If x is *known to be* a promise".

But, if I understand correctly, that part is just a shortcut it's allowed to take if it can prove it's safe to do so.
Moving on, the relevant section seems to be 2.3.3, which I summarize as: treat the return value x like a promise
iff x has a property named "then" which is a function.

So then it all rests on the definition of "x.then is a function".
What does that mean, precisely, for the purposes of someone wanting to implement a conformant library,
or someone wanting to predict what a conformant library must/might do when I use it?
Is it the same as saying "typeof x.then === 'function'"?

Hoping for more clues, I looked into the spec of a supposedly-conformant implementation (or set of implementations), ES6 native promises,
which is linked from the Promises doc on MDN.
I believe the relevant section is 25.4.1.3.2: http://www.ecma-international.org/ecma-262/6.0/#sec-promise-resolve-functions.
It looks like the criterion in question is IsCallable(x.then); following the link to that,
I see to my dismay that IsCallable is not an actual function but rather an "abstract operation",
defined in terms of many other "abstract operations" which are far from simple.

At this point, my hope of seeing any conformant reference code which implements the decision in question appears to be rapidly receding :-(

Backing up to my original question "How does promise resolution decide whether to treat a return value as a promise?",
I *think* I've boiled it down, as I explained above, to the more specific question: Exactly what does the Promises/A+ spec mean when it says "is a function"?

If that has a simple clear answer (which of course might allow room for variation among implementations),
follow-up questions would be:
- Does native promises conform to the simple clear answer?
- Why is native promises' implementation of promises/A+'s "is a function" so complicated?
- What's a reasonable way for me to ensure that my return value will be treated as a promise as I intend,
  or as a plain value as I intend?
