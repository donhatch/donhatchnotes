Trying to learn javascript promises.
Very good material:
  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
  https://davidwalsh.name/promises
  http://www.html5rocks.com/en/tutorials/es6/promises/
  http://www.sitepoint.com/overview-javascript-promises/
  http://www.datchley.name/es6-promises/
  https://www.promisejs.org/
  http://www.mattgreer.org/articles/promises-in-wicked-detail/

  http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html (especially see "Advanced mistakes" which is actually a nice collection of good practices)
  http://stackoverflow.com/questions/33377614/nolans-promises-a-javascript-puzzles

  https://developers.google.com/web/updates/2015/03/introduction-to-fetch
  https://davidwalsh.name/fetch

  http://blog.soareschen.com/the-problem-with-es6-promises -- good, articulates my concern about return values
  https://github.com/soareschen/es6-promise-debugging -- supposedly addresses it?  I didn't see it addressed

  https://www.stephanboyer.com/post/107/fun-with-promises-in-javascript -- good critique of the "helpful" behavior and how it should have been done (Surprise #1)




I'm having a really hard time absorbing it.


==================
http://stackoverflow.com/questions/36178889/after-adding-a-listener-to-a-promise-should-i-use-the-original-promise-or-the-n
Q: after adding a listener to a Promise, should I use the original promise or the new one?

I have some javasript code that takes an existing promise
(say, the promise returned by fetch()) and adds value
(say, then/catch listeners for debugging, or maybe more):

<code>let myFetch = function(url) {
  return fetch(url).then(function(value) {
    console.log("fetch succeeded: value=",value);
    return value;
  }.catch(function(reason) {
    console.log("fetch failed: reason=",reason);
    throw reason;
  });
};
</code>

I found myself modifying the above code so that the listeners are only added if some condition is true:

<code>let myFetch = function(url) {
  let promise = fetch(url);
  if (some condition) {
    promise = promise.then(function(value) {
      console.log("fetch succeeded: value=",value);
      return value;
    }.catch(function(reason) {
      console.log("fetch failed: reason=",reason);
      throw reason;
    });
  }
  return promise;
};
</code>

Now I'm wondering, does it really make sense for myFetch to return the new promise returned by "then"
(actually catch which is shorthand for another "then") as above,
or would it make more sense for it to return the original promise (with the added listeners)?
In other words, I'm thinking of leaving out the second "promise =",
so that the code will look like this instead:

<code>let myFetch = function(url) {
  let promise = fetch(url);
  if (some condition) {
    promise.then(function(value) {
      console.log("fetch succeeded: value=",value);
      return value;
    }.catch(function(reason) {
      console.log("fetch failed: reason=",reason);
      throw reason;
    });
  }
  return promise;
};
</code>

Is that effectively different from the previous version?
Is either version preferable, and if so, why?

==================
==================
I posted this:
http://stackoverflow.com/questions/35375730/is-javascript-promise-api-more-convoluted-than-it-needs-to-be
Q: Is javascript Promise API more convoluted than it needs to be?

I think I have finally managed to bend my mind around javascript/ES6 Promises, for the most part.  It wasn't easy!  But there's something that's baffling me about the design.

Why does the Promise constructor take a callback?  Given that the callback is called immediately, couldn't the caller just execute that code instead, thereby avoiding one unnecessary level of mind-bending "don't call me, I'll call you"?

Here's what I think of as the prototypical example of Promise usage, copied from Jake Archibald's Javascript Promises tutorial http://www.html5rocks.com/en/tutorials/es6/promises/#toc-promisifying-xmlhttprequest , with comments stripped.  It's a Promise-based wrapper for an XMLHttpRequest GET request:

<code>function get(url) {
  return new Promise(function(resolve, reject) {
    var req = new XMLHttpRequest();
    req.open('GET', url);
    req.onload = function() {
      if (req.status == 200) {
	resolve(req.response);
      }
      else {
	reject(Error(req.statusText));
      }
    };
    req.onerror = function() {
      reject(Error("Network Error"));
    };
    req.send();
  });
}
</code>

For me, the above code would be much easier to understand if it were rewritten as follows, using a very slightly different kind of promise that I'm imagining, having a no-arg constructor and resolve/reject methods:

<code>function get(url) {
  var promise = new MyEasierToUnderstandPromise();

  var req = new XMLHttpRequest();
  req.open('GET', url);
  req.onload = function() {
    if (req.status == 200) {
      promise.resolve(req.response);
    }
    else {
      promise.reject(Error(req.statusText));
    }
  };
  req.onerror = function() {
    promise.reject(Error("Network Error"));
  };
  req.send();

  return promise;
}
</code>

MyEasierToUnderstandPromise is not too hard to implement in terms of Promise.  At first I tried making it an actual subclass of Promise, but for some reason I couldn't get that to work; so instead I implemented it as a simple factory function, which returns a plain old Promise object with a couple of extra functions
attached that behave like member functions:

<code>function NewMyEasierToUnderstandPromise() {
  var resolveVar;
  var rejectVar;
  var promise = new Promise(function(resolveParam, rejectParam) {
    resolveVar = resolveParam;
    rejectVar = rejectParam;
  });
  promise.resolve = resolveVar;
  promise.reject = rejectVar;
  return promise;
};
</code>

So, why isn't Promise designed like this?  I think if it was, it would have helped me to understand Promises a lot quicker-- I bet it would have cut my learning time in half.

I know a lot of smart people had a hand in making the Promise API, and everyone seems to be generally happy and proud of it, so I'm wondering what they were thinking.




===========================
<code>
  function MyEasierToUnderstandPromise() {
    Promise.call(this, function(resolve, reject) {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
</code>


===============================================================================
Q: Why doesn't javascript Promise support multiple value args?
   It makes it awkward to convert old non-promise-based API, e.g.
   the new version typically looks like this:
     promise.then(function(valueArray) {
         let value0 = valueArray[0];
         let value1 = valueArray[1];
         let value2 = valueArray[2];
         ...
     });
   whereas the callback is more naturally written as:
     function(value0, value1, value2) { ... }
A: Well, "resolve" and "then" have to return a value, but return values can't
   be multiple.  Arguably it would have worked if "resolve" and "then"
   *always* return an array, but I guess the library designers wanted to
   optimize for the common case of a single return value instead.
   However, there is something called "spread" in some promise libraries:
     http://bluebirdjs.com/docs/api/spread.html
   That lets the above be written as:
      promise.spread(function(value0, value1, value2) { ... })
   However, this is really unnecessary in most cases, as pointed out in the
   Bluebird doc; it can be rewritten using ES6 destructuring syntax as:
      promise.spread([value0, value1, value2]) { ... })
===============================================================================
http://stackoverflow.com/questions/36312648/how-does-promise-resolution-decide-whether-to-treat-a-return-value-as-a-promise
  Q: how does promise resolution decide whether to treat a return value as a promise or as a plain value?

  Promise resolution "helpfully" does different things depending on whether the return value of resolve() or the return value of the function passed to then() is a promise or not.

  Therefore, understanding and predicting the behavior requires knowing precisely what criterion is being used (or is allowed to be used) to determine whether something "is a promise" as I use the phrase in the above sentence, so I'd like to nail that down.  I'm interested in Promises/A+ in general, and ES6 native promises in particular.

  Looking to https://promisesaplus.com/, it says:

      1.1 "promise" is an object or function with a "then" method whose behavior conforms to this specification.

  To see what that means, I look further into 2.2 "The then method", and find that it rests on a set of
  behavior criteria making it clearly impossible to decide algorithmically whether a given object
  is a promise or not (proof by Halting Problem).  And that's fine; it just means the spec
  of the "helpful" behavior in question won't be using the term "is a promise" directly.

  So, looking further for the spec of the "helpful" behavior, I find 2.3 "The Promise Resolution Procedure".
  Surprise!  It *does* use the term "is a promise" directly:

      2.3.2 If x is a promise, adopt its state [3.4]

  But it saves itself from a descent into meaninglessness in the footnote:

      [3.4] Generally, it will only be known that x is a true promise if it comes from the current implementation. This clause allows the use of implementation-specific means to adopt the state of known-conformant promises.

  In other words, 2.3.2 didn't really mean "If x is a promise", it really meant (and should have said, IMO) "If x is *known to be* a promise".

  But, if I understand correctly, that part is just a shortcut it's allowed to take if it can prove it's safe to do so.
  Moving on, the relevant section seems to be 2.3.3, which I summarize as: treat the return value x like a promise
  iff x has a property named "then" which is a function.

  So then it all rests on the definition of "x.then is a function".
  What does that mean, precisely, for the purposes of someone wanting to implement a conformant library,
  or someone wanting to predict what a conformant library must/might do when I use it?
  Is it the same as saying "typeof x.then === 'function'"?

  Hoping for more clues, I looked into the spec of a supposedly-conformant implementation (or set of implementations), ES6 native promises,
  which is linked from the Promises doc on MDN.
  I believe the relevant section is 25.4.1.3.2: http://www.ecma-international.org/ecma-262/6.0/#sec-promise-resolve-functions.
  It looks like the criterion in question is IsCallable(x.then); following the link to that,
  I see to my dismay that IsCallable is not an actual function but rather an "abstract operation",
  defined in terms of many other "abstract operations" which are far from simple.

  At this point, my hope of seeing any conformant reference code which implements the decision in question appears to be rapidly receding :-(

  Backing up to my original question "How does promise resolution decide whether to treat a return value as a promise?",
  I *think* I've boiled it down, as I explained above, to the more specific question: Exactly what does the Promises/A+ spec mean when it says "is a function"?

  If that has a simple clear answer (which of course might allow room for variation among implementations),
  follow-up questions would be:
  - Does native promises conform to the simple clear answer?
  - Why is native promises' implementation of promises/A+'s "is a function" so complicated?
  - What's a reasonable way for me to ensure that my return value will be treated as a promise as I intend,
    or as a plain value as I intend?
=======================================================================================
Q: in https://github.com/promises-aplus/promises-spec/issues/94#issuecomment-16239382
   it says "This also feeds into discussions of flattening promise chains; it has previously been discussed over and over that a promise-for-a-thenable is a problematic pattern in JavaScript and should not be supported. (A promise for another monad, of course, is fine.)".
   Can someone provide pointers to where this has been discussed over and over?
   (I asked)


Possible references for promise-for-a-promise:
  https://github.com/promises-aplus/promises-spec/issues/97#issuecomment-16319350
  Should I be looking at this "fantasy land"?
    https://github.com/fantasyland/fantasy-promises
  Wow, the implementation is really small.


  ==========================================
Relevant links to the problem in question:
http://stackoverflow.com/questions/36312648/how-does-promise-resolution-decide-whether-to-treat-a-return-value-as-a-promise
http://stackoverflow.com/questions/27746304/how-do-i-tell-if-an-object-is-a-promise/27746324#comment67620804_27746324
http://stackoverflow.com/questions/29435262/regarding-promises-a-specification-what-is-the-difference-between-the-terms-t/29435437#comment67807705_29435437

Wed Oct 26 19:26:15 PDT 2016
  I filed this bug against the spec:
  https://github.com/promises-aplus/promises-spec/issues/240
  ==========================================
    Title: change "if x is a promise" to something non-circular and clear

    The promises/A+ spec currently has a clause saying "If x is a promise, adopt its state [3.4]:"
    where footnote [3.4] is: "Generally, it will only be known that x is a true promise if it comes from the current implementation.
    This clause allows the use of implementation-specific means to adopt the state of known-conformant promises."

    Notice that, according to the earlier definition of "promise",
    "If x is a promise" means "If x is an object or function with a 'then' method whose behavior conforms to this specification",
    where "this specification" includes the clause in question.

    In other words, the definition of "promise" is circular.

    If [3.4] is an attempt to clarify, it fails.

    The clause in question should be changed to something non-circular and clear:
      - Do not use the words "if x is a promise" or any other self-referential phrase here.
      - If the clause is to say "if SOMETHING(x), adopt its state", then clearly say what is meant by SOMETHING(x).
        In other words, if it's intended that the implementation has latitude here, then clearly say how much latitude,
        so that it will be meaningful to ask, and possible to tell, whether any particular straightforward implementation
        is conformant or not from looking at the source code.

    In particular, it should be possible to discern whether each of the following possible
    implementations of the boolean function SOMETHING(x) is conformant:
      - function(x) { return typeof(x.then) == 'function'; }
      - function(x) { return typeof(x.then) === 'function'; }
      - function(x) { return x instanceof SomePromisesImplementation.Promise
                          || x instanceof SomeOtherPromisesImplementation.WhateverItCallsAPromise; }
      - function(x) { return false; }
      - function(x) { return true; }
      - function(x) { return Math.random() >= 0.5; }
  ==========================================

Wed Oct 26 19:42:51 PDT 2016
  Added the following comment:
  ==========================================
    I think one reasonable possible resolution would be to change "If x is a promise, adopt its state [3.4]:"
    to "**(Optional)** If x is **known to be** a promise, adopt its state [3.4]:".

    Even though this is still self-referential, I believe this will make it clear and meaningful.

    In particular, the questions of whether the 6 SOMETHING(x) functions shown at the end of my original post are conformant can then be answered:
    NO, NO, YES (assuming we trust the two implementations are conformant to the entire spec), YES, NO, NO.
  ==========================================
Wed Oct 26 21:37:29 PDT 2016
  adding another comment to http://stackoverflow.com/questions/27746304/how-do-i-tell-if-an-object-is-a-promise/27746324

  @BenjaminGruenbaum , are you aware that the Promises/A+ spec to which you're referring also has an earlier section `2.3.2. If x is a promise, adopt its state [3.4]:`?
  This is a clearly different section from 2.3.3.3, with different intent and necessarily different criteria.
  So the definitive-sounding first section of your answer ("How a promise library decides: If it has a `.then` function - that's the *only* standard promise libraries use") appears to be quite incorrect.
  [and subsequent not-entirely-pleasant discussion]
  [I should write my own answer to this one]

