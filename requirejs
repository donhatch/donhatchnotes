REQUIRED READING:
  http://stackoverflow.com/questions/18512503/can-someone-explain-the-syntax-involved-in-this-require-js-example#answer-18513994
  which refers to this excellent article:
    http://aaronhardy.com/javascript/javascript-architecture-requirejs-dependency-management/
NOTES:
  - At top level, `require` is the same as `requirejs`
  - `define(['a'], function(){})` doesn't mean "define a";
    it means "Here's my module definition for this file,
    which depends on 'a'".
  - I think if I want to use some modules using dojo,
    maybe I can't call "require"?  Not sure.
    I seemed to run into some trouble until I rewrote it using only
    `define` and no using `require` inside the define.

QUESTIONS:

Q: How does requirejs know to load a required file before I even mention the file name?
   http://stackoverflow.com/questions/42172792/how-does-requirejs-know-to-load-a-required-js-file-before-i-ever-mention-the-fil
A: Sneaky magic, it's called the "Simplified CommonJS wrapper";
   it actually parses the callback code, necessarily somewhat naively,
   and makes assumptions about it.
   See the answer to my question, and also these:
    http://stackoverflow.com/questions/28341390/when-is-requirejs-require-call-asynchronous-when-is-it-synchronous
    http://stackoverflow.com/questions/34661039/how-does-the-simplied-commonjs-wrapper-work-in-require-js-under-the-hood
   Note that it works in `define`, but *not* in `require`!

Q: I've heard it said that `define` is lazy; that is, the callback
   isn't executed until it's needed.  What's an example of this?
   This guy claims to show an example of it, but I can't seem to reproduce it;
   see my question attached to the answer:
   http://stackoverflow.com/questions/18534912/requirejs-difference-between-require-and-define#answer-18535142#comment-71533847

Q: On the face of it, "define" seems to the same as "require" except that
   its callback returns a value which the calling "define" or "require"
   can access via a function argument.
   So, are "define" and "require" otherwise interchangeable?
   I.e. (1) can "define" always be used in place of "require"? (2) can "require" always be used in place of "define" when the return value isn't used? (3) if the answer to (1) is "yes", then is there any reason for "require" to exist at all?
   Note that there are several questions that appear to be related to this on stackoverflow;
   however, I think most of the answers are framed in a way that isn't
   helpful to me; they talk about intent while leaving open the possibility
   that the functions are essentially the same other than accessibility of
   return value.
     http://stackoverflow.com/questions/9507606/when-should-i-use-require-and-when-to-use-define
     http://stackoverflow.com/questions/17366073/requirejs-define-vs-require
     http://stackoverflow.com/questions/18534912/requirejs-difference-between-require-and-define
     http://stackoverflow.com/questions/21209359/requirejs-can-i-use-require-instead-of-define

   Maybe I could ask and answer another:
     "Is requirejs's `require` the same as `define` aside from lack of return value from the callback?"

A:
  (1) No!
      - `require` can be used at any point in javascript code at runtime,
        many times per file / function if desired;
        It means "schedule this callback to be run asynchronously, after ansychronously loading
        these dependencies (and the dependencies' dependencies, recursively)".
      - `define` means "here's the callback that produces the value
        to be returned to calling `define`s and `require`s when they ask for this file.
      - only the first `define` called during loading of the file by requirejs is honored (apparently).
        (Seems to me it would be better if this were an error?)
      - if `define` is called outside of being loaded as a dependency or `data-main` attr
        of require.js's script tag, it gives an error.
      - `define` is only honored during initial file load;
        e.g. if I put one inside a callback of a setTimeout(f, 1000), it never gets run.
        (Seems to me it would be better if this were an error?)
        (And if I put one inside a callback of a setTimeout(f, 0), it give an error...
        not sure exactly why this is an error and the setTimeout(f, 1000) isn't).
      - Supposedly `define` is only called if/when something requires or depends on it,
        which is maybe useful for lazy purposes, postponing/avoiding overhead?
        However, I can't reproduce this at all; see my other question about it.
  (2) No!
      - The crucial non-obvious thing here is timing: if I use `require` where I should
        have used `define`, things can get executed in an unfortunate order that results
        in errors.  While simple examples may appear to work, here's an example
        where it doesn't.

        In this example, PRINT.js and getStackTrace.js put respective functions
        PRINT and getStackTrace into the global namespace, and PRINT calls getStackTrace.

        TODO: put the important parts of the file contents here

        If PRINT.js has a `define` declaring dependency on getStacktrace.js,
        I get the expected sequence of execution:
	  main.js loaded
	  PRINT.js loaded
	  getStackTrace.js loaded
          getStackTrace.js's define callback called (if any-- it's optional, don't know why)
	  PRINT.js's define callback called
	  main.js's require or define callback executed, which calls PRINT(), which calls getStackTrace(); all good

        Whereas if I replace PRINT.js's `define` with `require`:
	  main.js loaded
	  PRINT.js loaded (requirejs is looking for define, which doesn't happen)
	  main.js's require callback executed, which calls PRINT, which gives error to console:
	    PRINT.js:102 Uncaught ReferenceError: getStackTrace is not defined
	  getStackTrace.js loaded
          getStackTrace.js's define callback called (if any)
	  PRINT.js's require callback called

        So the crucial difference is the relative order of main.js's
        and PRINT.js's callbacks: PRINT.js's define callback gets executed
        before main.js's require or define callback
        (which implies all PRINT.js's dependencies got loaded even before that).
        Whereas PRINT.js's require callback gets executed after main.js's callback
        (or at least *can* get executed after it), because supposedly nothing
        depends on its result; that means functions in PRINT, although defined,
        may not be *usable* by the time main.js require callback is called,
        resulting in error.

        One way of thinking about this is that `define` is a synchronization point:
        the define's dependencies get loaded *before* the define's callback,
        and the caller's callback (require or define) gets called *after*
        the define's callback.  Therefore, the define's dependencies get
        loaded before main.js's callback, which prevents errors when main.js
        invokes the intermediate module's functions which call the dependent
        modules functions.


      - Given that `require` is *not* a valid substitute for `define` even though
        it appears to be so, and using `require` instead of `define` is easy to get wrong,
        and that there seems to be no legitimate use case for failing to have `define`
        in a file that gets depended on, it seems to me it would be better if
        requirejs would err on failure for a depended-on file to execute `define`
        during file load, instead of silentl proceeding.

  (3) N/A since the answer to (1) is "no".

Q: I'm now loading all modules that are in current directory as
   './someModule.js'.   It *sometimes* seems to work if the './' is omitted
   and/or if the '.js' is omitted, but I think I've had bad luck with both
   in a dojo setting (e.g. if I omit the .js, it would try to load the thing
   from the dojo subdirectory, and if I omit the .js, something else
   bad would happen... although maybe that was just if I had .js an some places
   and omitted otherwise).  Get straight on exactly what the problems were
   and exactly what the recommendations are, and what conventions
   are required in order to get both requirejs and dojo's AMD functionality
   to work?

Q: Can I use requirejs and dojo's AMD functionality interchangeably?
   If not, what's the greatest common subset of functionality?

Q: Is there some clever way I can require PRINT.js
   in a way that makes PRINT.js load the caller before continuing?

   Let's see if I can frame this in a way that's suitable...
   Hmm, maybe make it more self-contained first?
   (i.e. not dependent on getStackTrace.js)



   Q: how to define a module that reads the caller's source code?

   I have a couple of use cases where I'm writing a function
   that needs to read its caller's source code.
   These are utility functions for developer productivity.

   Use case #1: PRINT
     PRINT(<expression>) should print to the console:
       <expression> = <value>
     For example:
       PRINT(1+2);                  // "1+2 = 3"
       PRINT([1,2,3].length);       // "[1,2,3].length = 3"
       let a = 3; PRINT(a);         // "a = 3"
       let b = {x:8,y:9}; PRINT(b); // "b = {x:8,y:9}"

   Use case #2: CHECK
     CHECK(<boolean expression>) should throw a new Error("CHECK failed: <boolean expression> at <caller function> (<caller file>:<caller line>)")
     if <boolean expression> evaluates to false.
     For example, when called from fun() in foo.js:
       CHECK(true);     // (does nothing)
       CHECK(1+1===2);  // (does nothing)
       CHECK(false);    // throw new Error("CHECK failed: false at fun (foo.js:3)");
       CHECK(1+1===3);  // throw new Error("CHECK failed: 1+1===3 at fun (foo.js:4)");

   How can I implement PRINT and CHECK?
       
   IMPLEMENTATION #1: Synchronously load the caller's source file
     getStackTrace.js:
       // Assumes require.js has been loaded
       define([], function() {
         return function getStackTrace() {
         };
       });
     PRINT.js:
       // Assumes require.js has been loaded
       define(['./getStackTrace.js'], function(getStackTrace) {
         return function PRINT() {
           ...
         };
       });
     CHECK.js:
       // Assumes require.js has been loaded
       define(['./getStackTrace.js'], function(getStackTrace) {
         return function CHECK() {
           ...
         };
       });
      main.js:
       // Assumes require.js has been loaded
       require(['PRINT', 'CHECK'], function fun(PRINT, CHECK) {
         PRINT(1 + 2);                // "1 + 2 = 3"
         PRINT([1,2,3].length);       // "[1,2,3].length = 3"
         let a = 3; PRINT(a);         // "a = 3"
         let b = {x:8,y:9}; PRINT(b); // "b = {x:8,y:9}"
         CHECK(true);     // (does nothing)
         CHECK(1+1===2);  // (does nothing)
         CHECK(1+1===3);  // throw new Error("CHECK failed: 1+1===3 at fun (foo.js:8)");
       });
       
   That works, but it has a problem: it loads the source files synchronously,
   which provokes the following warning in chrome:
     [...]
   and I suspect future versions will disallow synchronous loading entirely.
   So I need to write this all the right way-- that is, asynchronously.

   IMPLEMENTATION #2: Asynchronously load caller's source file (only works from main):
     getStackTrace.js:
       (same as in IMPLEMENTATION #1)
     PRINT.js:
       // Assumes require.js has been loaded
       define(['./getStackTrace.js'], function(getStackTrace) {
         return {
           withPRINT: function(callback) {
             let callerURL = ...;
             fetch(callerURL).then(function() {
               callback(function PRINT(expr) {
               });
             };
           },
         };
       });
     CHECK.js:
       // Assumes require.js has been loaded
       define(['./getStackTrace.js'], function(getStackTrace) {
         return {
           withCHECK: function(callback) {
             let callerURL = ...;
             fetch(callerURL).then(function() {
               callback(function CHECK(expr) {
               });
             };
           },
         };
       });
     main.js:
       // Assumes require.js has been loaded
       require(['PRINT', 'CHECK'], function fun(PRINTmodule, CHECKmodule) {
         PRINTmodule.withPRINT(function(PRINT) {
           CHECKmodule.withCHECK(function(CHECK) {
             PRINT(1 + 2);                // "1 + 2 = 3"
             PRINT([1,2,3].length);       // "[1,2,3].length = 3"
             let a = 3; PRINT(a);         // "a = 3"
             let b = {x:8,y:9}; PRINT(b); // "b = {x:8,y:9}"
             CHECK(true);     // (does nothing)
             CHECK(1+1===2);  // (does nothing)
             CHECK(1+1===3);  // throw new Error("CHECK failed: 1+1===3 at fun (foo.js:10)");
           });
         };
       };

   Implementation #2 works as desired, and isn't too awful.

   But it is not a complete solution: it only works for calling PRINT and CHECK
   from the main program (i.e. from the callback of a `require`).
   I also need to be able to call PRINT and CHECK from within other modules
   (i.e. to call them from a function returned by the callback of a `define`).

   What is the cleanest way to implement this?
